# âœ… å®‰è£…æ‰€éœ€åº“ï¼ˆå¦‚æœªå®‰è£…ï¼‰
!pip install openai pandas scipy numpy openpyxl tqdm

# âœ… å¯¼å…¥åº“
import openai
import numpy as np
import pandas as pd
from scipy.spatial.distance import cdist
from tqdm import tqdm
import matplotlib.pyplot as plt
from getpass import getpass

# âœ… è®¾ç½® OpenAI API key
# openai_api_key = getpass("ğŸ” è¯·è¾“å…¥ä½ çš„ OpenAI API Key: ")
openai.api_key = ""

# âœ… åµŒå…¥å‡½æ•°
def get_embedding(text, model="text-embedding-3-large"):
    response = openai.embeddings.create(
        input=text,
        model=model,
        encoding_format="float"
    )
    return np.array(response.data[0].embedding)

# ä¸Šä¼  Excel æ–‡ä»¶ï¼ˆæˆ–ä½¿ç”¨ Google Driveï¼‰
from google.colab import files
uploaded = files.upload()

# è‡ªåŠ¨è¯†åˆ«ç¬¬ä¸€ä¸ªä¸Šä¼ çš„æ–‡ä»¶å
excel_path = list(uploaded.keys())[0]

# è¯»å– Excel
df = pd.read_excel(excel_path)

# âœ… æå–æ–‡æœ¬åˆ—ï¼ˆå‡è®¾æ˜¯ A å’Œ Bï¼‰
texts_a = df.iloc[:, 0].astype(str).tolist()
texts_b = df.iloc[:, 1].astype(str).tolist()

# âœ… è·å–åµŒå…¥ï¼ˆå¸¦è¿›åº¦æ¡ï¼‰
embeddings_a = np.array([get_embedding(text) for text in tqdm(texts_a, desc="Embedding A")])
embeddings_b = np.array([get_embedding(text) for text in tqdm(texts_b, desc="Embedding B")])

# âœ… Cosine ç›¸ä¼¼åº¦è®¡ç®—ï¼ˆé€è¡Œå¯¹åº”ï¼‰
def assess_cos_similarity(matrix1, matrix2):
    dot_product = np.sum(matrix1 * matrix2, axis=1)
    norm1 = np.linalg.norm(matrix1, axis=1)
    norm2 = np.linalg.norm(matrix2, axis=1)
    cosine_similarities = dot_product / (norm1 * norm2)
    return cosine_similarities

# âœ… æ¬§å‡ é‡Œå¾—è·ç¦»ï¼ˆé€è¡Œå¯¹åº”ï¼‰
def assess_euclidean_distance(matrix1, matrix2):
    return np.linalg.norm(matrix1 - matrix2, axis=1)

# âœ… Permutation Test
def permutation_test(matrix1, matrix2, n_permutations=1000, metric='cosine', seed=42):
    np.random.seed(seed)
    combined = np.vstack((matrix1, matrix2))
    obs_stat = np.mean(cdist(matrix1, matrix2, metric=metric))

    perm_stats = []
    for _ in range(n_permutations):
        np.random.shuffle(combined)
        perm_group1 = combined[:len(matrix1)]
        perm_group2 = combined[len(matrix1):]
        perm_stat = np.mean(cdist(perm_group1, perm_group2, metric=metric))
        perm_stats.append(perm_stat)

    perm_stats = np.array(perm_stats)
    p_value = np.mean(perm_stats >= obs_stat)
    effect_size = (obs_stat - np.mean(perm_stats)) / np.std(perm_stats)

    print("Permutation Test Summary:")
    print(f"Observed Statistic: {obs_stat:.4f}")
    print(f"p-value: {p_value:.4f}")
    print(f"Effect Size (Cohen's d): {effect_size:.4f}")

    # å¯é€‰ï¼šç»˜å›¾
    plt.hist(perm_stats, bins=50, alpha=0.7, label='Permuted')
    plt.axvline(obs_stat, color='red', linestyle='--', label='Observed')
    plt.legend()
    plt.title(f"Permutation Test ({metric} distance)")
    plt.xlabel("Distance")
    plt.ylabel("Frequency")
    plt.show()

# âœ… æ‰§è¡Œç›¸ä¼¼åº¦åˆ†æ
cos_sim = assess_cos_similarity(embeddings_a, embeddings_b)
euc_dist = assess_euclidean_distance(embeddings_a, embeddings_b)

print(f"\nAverage Cosine Similarity: {cos_sim.mean():.4f} Â± {cos_sim.std():.4f}")
print(f"Average Euclidean Distance: {euc_dist.mean():.4f} Â± {euc_dist.std():.4f}")

# âœ… æ‰§è¡Œ permutation test
permutation_test(embeddings_a, embeddings_b, metric='cosine')
