# ✅ 安装所需库（如未安装）
!pip install openai pandas scipy numpy openpyxl tqdm

# ✅ 导入库
import openai
import numpy as np
import pandas as pd
from scipy.spatial.distance import cdist
from tqdm import tqdm
import matplotlib.pyplot as plt
from getpass import getpass

# ✅ 设置 OpenAI API key
# openai_api_key = getpass("🔐 请输入你的 OpenAI API Key: ")
openai.api_key = ""

# ✅ 嵌入函数
def get_embedding(text, model="text-embedding-3-large"):
    response = openai.embeddings.create(
        input=text,
        model=model,
        encoding_format="float"
    )
    return np.array(response.data[0].embedding)

# 上传 Excel 文件（或使用 Google Drive）
from google.colab import files
uploaded = files.upload()

# 自动识别第一个上传的文件名
excel_path = list(uploaded.keys())[0]

# 读取 Excel
df = pd.read_excel(excel_path)

# ✅ 提取文本列（假设是 A 和 B）
texts_a = df.iloc[:, 0].astype(str).tolist()
texts_b = df.iloc[:, 1].astype(str).tolist()

# ✅ 获取嵌入（带进度条）
embeddings_a = np.array([get_embedding(text) for text in tqdm(texts_a, desc="Embedding A")])
embeddings_b = np.array([get_embedding(text) for text in tqdm(texts_b, desc="Embedding B")])

# ✅ Cosine 相似度计算（逐行对应）
def assess_cos_similarity(matrix1, matrix2):
    dot_product = np.sum(matrix1 * matrix2, axis=1)
    norm1 = np.linalg.norm(matrix1, axis=1)
    norm2 = np.linalg.norm(matrix2, axis=1)
    cosine_similarities = dot_product / (norm1 * norm2)
    return cosine_similarities

# ✅ 欧几里得距离（逐行对应）
def assess_euclidean_distance(matrix1, matrix2):
    return np.linalg.norm(matrix1 - matrix2, axis=1)

# ✅ Permutation Test
def permutation_test(matrix1, matrix2, n_permutations=1000, metric='cosine', seed=42):
    np.random.seed(seed)
    combined = np.vstack((matrix1, matrix2))
    obs_stat = np.mean(cdist(matrix1, matrix2, metric=metric))

    perm_stats = []
    for _ in range(n_permutations):
        np.random.shuffle(combined)
        perm_group1 = combined[:len(matrix1)]
        perm_group2 = combined[len(matrix1):]
        perm_stat = np.mean(cdist(perm_group1, perm_group2, metric=metric))
        perm_stats.append(perm_stat)

    perm_stats = np.array(perm_stats)
    p_value = np.mean(perm_stats >= obs_stat)
    effect_size = (obs_stat - np.mean(perm_stats)) / np.std(perm_stats)

    print("Permutation Test Summary:")
    print(f"Observed Statistic: {obs_stat:.4f}")
    print(f"p-value: {p_value:.4f}")
    print(f"Effect Size (Cohen's d): {effect_size:.4f}")

    # 可选：绘图
    plt.hist(perm_stats, bins=50, alpha=0.7, label='Permuted')
    plt.axvline(obs_stat, color='red', linestyle='--', label='Observed')
    plt.legend()
    plt.title(f"Permutation Test ({metric} distance)")
    plt.xlabel("Distance")
    plt.ylabel("Frequency")
    plt.show()

# ✅ 执行相似度分析
cos_sim = assess_cos_similarity(embeddings_a, embeddings_b)
euc_dist = assess_euclidean_distance(embeddings_a, embeddings_b)

print(f"\nAverage Cosine Similarity: {cos_sim.mean():.4f} ± {cos_sim.std():.4f}")
print(f"Average Euclidean Distance: {euc_dist.mean():.4f} ± {euc_dist.std():.4f}")

# ✅ 执行 permutation test
permutation_test(embeddings_a, embeddings_b, metric='cosine')
